import os
import time
from typing import List, Dict
from src.leetcode_client import LeetCodeClient
from src.github_client import GitHubClient

class SyncEngine:
    def __init__(self, leetcode_client: LeetCodeClient, github_client: GitHubClient):
        self.lc = leetcode_client
        self.gh = github_client
        
    def initialize_repo(self):
        """Creates the basic directory structure (Easy, Medium, Hard) on GitHub."""
        directories = ["Easy", "Medium", "Hard"]
        
        print("üöÄ Initializing repository structure...")
        
        for category in directories:
            path = f"{category}/README.md"
            content = f"# {category} Problems\n\nThis directory contains all my {category.lower()} difficulty LeetCode solutions."
            message = f"chore: initialize {category} directory"
            
            print(f"Creating {path}...")
            success = self.gh.create_or_update_file(path, content, message)
            if success:
                print(f"‚úÖ Created {category} folder.")
            else:
                print(f"‚ùå Failed to create {category} folder.")
            
            # Small delay to avoid hitting rate limits too fast (though GitHub is quite generous)
            time.sleep(0.5)

        print("\n‚ú® Repository structure initialized successfully!")

    def _get_file_extension(self, language: str) -> str:
        """Maps LeetCode language names to file extensions."""
        mapping = {
            "cpp": "cpp",
            "java": "java",
            "python": "py",
            "python3": "py",
            "mysql": "sql",
            "mssql": "sql",
            "oraclesql": "sql",
            "c": "c",
            "csharp": "cs",
            "javascript": "js",
            "ruby": "rb",
            "bash": "sh",
            "swift": "swift",
            "golang": "go",
            "scala": "scala",
            "kotlin": "kt",
            "rust": "rs",
            "php": "php",
            "typescript": "ts",
            "racket": "rkt",
            "erlang": "erl",
            "elixir": "ex",
            "dart": "dart"
        }
        return f".{mapping.get(language.lower(), 'txt')}"

    def _format_markdown(self, question_data: Dict, submission_data: Dict) -> str:
        """Creates a pretty README for an individual problem."""
        difficulty = question_data['difficulty']
        title = question_data['title']
        q_id = question_data['questionFrontendId']
        content = question_data['content'] # This is HTML
        
        runtime = submission_data['runtimeDisplay']
        memory = submission_data['memoryDisplay']
        lang = submission_data['lang']['verboseName']
        timestamp = submission_data['timestamp']
        date_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(int(timestamp)))

        # Color mapping for difficulty
        diff_color = {
            "Easy": "brightgreen",
            "Medium": "orange",
            "Hard": "red"
        }.get(difficulty, "blue")

        md = f"""# [{q_id}. {title}](https://leetcode.com/problems/{question_data['titleSlug']}/)

![Difficulty: {difficulty}](https://img.shields.io/badge/Difficulty-{difficulty}-{diff_color})

## Problem Description
{content}

## Submission Details
- **Status**: Accepted
- **Language**: {lang}
- **Runtime**: {runtime}
- **Memory**: {memory}
- **Date**: {date_str}

---
*Generated by [LeetcodeUploader](https://github.com/Hetul3/LeetcodeUploader)*
"""
        return md

    def sync(self, username: str, limit: int = 20):
        """
        The main sync loop. Fetches history, filters for latest per language,
        checks against GitHub, and uploads.
        """
        print(f"üîç Fetching your last {limit} accepted submissions...")
        recent_submissions = self.lc.get_recent_accepted_submissions(username, limit)
        total = len(recent_submissions)
        
        # Track (titleSlug, language) to only keep the LATEST one
        processed_pairs = set()
        
        for i, sub in enumerate(recent_submissions, 1):
            sub_id = sub['id']
            title_slug = sub['titleSlug']
            title = sub['title']
            
            # Fetch full details to check the language
            details = self.lc.get_submission_details(sub_id)
            lang_name = details['lang']['name']
            lang_verbose = details['lang']['verboseName']
            
            progress = f"[{i}/{total}]"
            
            # 1. Deduplication: Only take the latest for this (Problem, Language)
            pair_key = (title_slug, lang_name)
            if pair_key in processed_pairs:
                print(f"{progress} {title} ({lang_verbose}): ‚è© Skipped (Recent submission exists)")
                continue
            processed_pairs.add(pair_key)
            
            # 2. Extract metadata
            q_full_details = self.lc.get_question_details(title_slug)
            difficulty = q_full_details['difficulty']
            frontend_id = q_full_details['questionFrontendId']
            
            # 3. Construct Paths
            safe_title = title.replace(" ", "-").replace("/", "-")
            folder_path = f"{difficulty}/{frontend_id}-{safe_title}"
            extension = self._get_file_extension(lang_name)
            solution_path = f"{folder_path}/solution{extension}"
            readme_path = f"{folder_path}/README.md"
            
            # 4. Content Comparison
            new_code = details['code'].strip()
            existing_code = self.gh.get_file_content(solution_path)
            
            if existing_code and existing_code.strip() == new_code:
                print(f"{progress} {title} ({lang_verbose}): ‚úÖ Up to date")
            else:
                # Upload Solution
                commit_msg = f"feat: add/update {lang_verbose} solution for {title}"
                self.gh.create_or_update_file(solution_path, new_code, commit_msg)
                
                # Upload/Update README
                readme_content = self._format_markdown(q_full_details, details)
                self.gh.create_or_update_file(readme_path, readme_content, f"docs: update README for {title}")
                print(f"{progress} {title} ({lang_verbose}): üöÄ Synced")
                
            # Rate limiting delay
            time.sleep(0.5)

        print("\n‚ú® All done! Your GitHub repository is now synced.")
