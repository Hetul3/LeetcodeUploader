import os
import time
import re
import html2text
from typing import List, Dict
from .leetcode_client import LeetCodeClient
from .github_client import GitHubClient

class SyncEngine:
    def __init__(self, leetcode_client: LeetCodeClient, github_client: GitHubClient):
        self.lc = leetcode_client
        self.gh = github_client
        self.verified_categories = set()
        
    def _ensure_category_exists(self, category: str):
        """Checks if Easy/Medium/Hard directory exists, creates if missing."""
        if category in self.verified_categories:
            return
            
        path = f"{category}/README.md"
        if not self.gh.get_file_sha(path):
            print(f"üìÅ Creating category directory: {category}...")
            content = f"# {category} Problems\n\nThis directory contains all my {category.lower()} difficulty LeetCode solutions."
            message = f"chore: initialize {category} directory"
            self.gh.create_or_update_file(path, content, message)
            
        self.verified_categories.add(category)

    def _get_file_extension(self, language: str) -> str:
        """Maps LeetCode language names to file extensions."""
        mapping = {
            "cpp": "cpp",
            "java": "java",
            "python": "py",
            "python3": "py",
            "mysql": "sql",
            "mssql": "sql",
            "oraclesql": "sql",
            "c": "c",
            "csharp": "cs",
            "javascript": "js",
            "ruby": "rb",
            "bash": "sh",
            "swift": "swift",
            "golang": "go",
            "scala": "scala",
            "kotlin": "kt",
            "rust": "rs",
            "php": "php",
            "typescript": "ts",
            "racket": "rkt",
            "erlang": "erl",
            "elixir": "ex",
            "dart": "dart"
        }
        return f".{mapping.get(language.lower(), 'txt')}"

    def _format_markdown(self, question_data: Dict, submission_data: Dict) -> str:
        """Creates a pretty README for an individual problem."""
        difficulty = question_data['difficulty']
        title = question_data['title']
        q_id = question_data['questionFrontendId']
        html_content = question_data.get('content', '')
        
        # Convert HTML to clean Markdown
        h = html2text.HTML2Text()
        h.ignore_links = False
        h.body_width = 0  # Disable line wrapping for cleaner examples
        markdown_body = h.handle(html_content)

        # Topic Tags
        tags = [t['name'] for t in question_data.get('topicTags', [])]
        tags_md = " ".join([f"`{t}`" for t in tags])
        
        runtime = submission_data['runtimeDisplay']
        runtime_percentile = submission_data.get('runtimePercentile')
        memory = submission_data['memoryDisplay']
        memory_percentile = submission_data.get('memoryPercentile')
        
        lang = submission_data['lang']['verboseName']
        timestamp = submission_data['timestamp']
        date_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(int(timestamp)))

        # Color mapping for difficulty
        diff_color = {
            "Easy": "brightgreen",
            "Medium": "orange",
            "Hard": "red"
        }.get(difficulty, "blue")

        runtime_info = f"{runtime}"
        if runtime_percentile:
            runtime_info += f" (Better than {runtime_percentile:.2f}%)"
            
        memory_info = f"{memory}"
        if memory_percentile:
            memory_info += f" (Better than {memory_percentile:.2f}%)"

        md = f"""# [{q_id}. {title}](https://leetcode.com/problems/{question_data['titleSlug']}/)

![Difficulty: {difficulty}](https://img.shields.io/badge/Difficulty-{difficulty}-{diff_color})
{tags_md}

## Problem Description
{markdown_body}

## Submission Details
- **Status**: Accepted
- **Language**: {lang}
- **Runtime**: {runtime_info}
- **Memory**: {memory_info}
- **Date**: {date_str}

---
*Generated by [LeetcodeUploader](https://github.com/Hetul3/LeetcodeUploader)*
"""
        return md

    def sync(self, username: str, limit: int = 20):
        """
        The main sync loop. Fetches history, filters for latest per language,
        checks against GitHub, and uploads.
        """
        print(f"üîç Fetching your last {limit} accepted submissions...")
        recent_submissions = self.lc.get_recent_accepted_submissions(username, limit)
        total = len(recent_submissions)
        
        # Track (titleSlug, language) to only keep the LATEST one
        processed_pairs = set()
        
        for i, sub in enumerate(recent_submissions, 1):
            sub_id = sub['id']
            title_slug = sub['titleSlug']
            title = sub['title']
            
            # Fetch full details to check the language
            details = self.lc.get_submission_details(sub_id)
            lang_name = details['lang']['name']
            lang_verbose = details['lang']['verboseName']
            
            progress = f"[{i}/{total}]"
            
            # 1. Deduplication: Only take the latest for this (Problem, Language)
            pair_key = (title_slug, lang_name)
            if pair_key in processed_pairs:
                print(f"{progress} {title} ({lang_verbose}): ‚è© Skipped (Recent submission exists)")
                continue
            processed_pairs.add(pair_key)
            
            # 2. Extract metadata
            q_full_details = self.lc.get_question_details(title_slug)
            difficulty = q_full_details['difficulty']
            frontend_id = q_full_details['questionFrontendId']
            
            # Ensure the category folder (Easy/Medium/Hard) exists
            self._ensure_category_exists(difficulty)
            
            # 3. Construct Paths
            safe_title = title.replace(" ", "-").replace("/", "-")
            folder_path = f"{difficulty}/{frontend_id}-{safe_title}"
            extension = self._get_file_extension(lang_name)
            solution_path = f"{folder_path}/solution{extension}"
            readme_path = f"{folder_path}/README.md"
            
            # 4. Content Comparison
            new_code = details['code'].strip()
            existing_code = self.gh.get_file_content(solution_path)
            
            # Formulate the new README to compare
            new_readme = self._format_markdown(q_full_details, details)
            existing_readme = self.gh.get_file_content(readme_path)
            
            code_changed = not existing_code or existing_code.strip() != new_code
            readme_changed = not existing_readme or existing_readme.strip() != new_readme.strip()

            if not code_changed and not readme_changed:
                print(f"{progress} {title} ({lang_verbose}): ‚úÖ Up to date")
            else:
                action = "Updating" if (existing_code or existing_readme) else "Syncing"
                # Upload Solution if changed
                if code_changed:
                    commit_msg = f"feat: update {lang_verbose} solution for {title}"
                    self.gh.create_or_update_file(solution_path, new_code, commit_msg)
                
                # Upload/Update README if changed
                if readme_changed:
                    self.gh.create_or_update_file(readme_path, new_readme, f"docs: update README for {title}")
                
                print(f"{progress} {title} ({lang_verbose}): üöÄ {action}")
                
            # Rate limiting delay
            time.sleep(0.5)

        print("\n‚ú® All done! Your GitHub repository is now synced.")
